global.CONNECT_TO_ROOM_SERVER=METHOD(e=>{const o="__";let t={},d={},m={},r={},i={},n={},a={};e.checkIsConnected=(e=>{return void 0===e&&(e=o),void 0===r[e]&&(r[e]=!1),r[e]}),e.enterRoom=(e=>{let d=e.roomServerName,m=e.roomName;void 0===d&&(d=o);let r=t[d];void 0===r&&(r=t[d]=[]),r.push(m),void 0!==a[d]&&a[d]({methodName:"__ENTER_ROOM",data:m})}),e.on=((e,t)=>{let m=e.roomServerName,r=e.methodName;void 0===m&&(m=o);let n=d[m];void 0===n&&(n=d[m]=[]),n.push({methodName:r,method:t}),void 0!==i[m]&&i[m](r,t)}),e.off=((e,t)=>{let m=e.roomServerName,r=e.methodName;void 0===m&&(m=o);let i=d[m];void 0!==n[m]&&n[m](r,t),void 0!==i&&(void 0!==t?REMOVE(i,e=>{return e.methodName===r&&e.method===t}):REMOVE(i,e=>{return e.methodName===r}),0===i.length&&delete d[m])}),e.send=((e,t)=>{let d=e.roomServerName,r=e.methodName,i=e.data;if(void 0===d&&(d=o),void 0===a[d]){let e=m[d];void 0===e&&(e=m[d]=[]),e.push({params:{methodName:r,data:i},callback:t})}else a[d]({methodName:r,data:i},t)}),e.exitRoom=(e=>{let d=e.roomServerName,m=e.roomName;void 0===d&&(d=o);let r=t[d];void 0===r&&(r=t[d]=[]),void 0!==a[d]&&a[d]({methodName:"__EXIT_ROOM",data:m}),EACH(r,(e,o)=>{if(e===m)return REMOVE({array:r,key:o}),!1})});return{run:(e,c)=>{let v,u,N=e.roomServerName;void 0===N&&(N=o),void 0!==c&&(CHECK_IS_DATA(c)!==!0?v=c:(v=c.success,u=c.error)),CONNECT_TO_WEB_SOCKET_SERVER({isSecure:e.isSecure,host:e.host,port:e.port},{error:u,success:(e,o,c)=>{let u=t[N],E=d[N],h=m[N];i[N]=e,n[N]=o,a[N]=c,void 0!==u&&EACH(u,e=>{c({methodName:"__ENTER_ROOM",data:e})}),void 0!==E&&EACH(E,o=>{e(o.methodName,o.method)}),void 0!==h&&EACH(h,e=>{c(e.params,e.callback)}),delete m[N],void 0!==v&&v(e,o,c),r[N]=!0,e("__DISCONNECTED",()=>{delete i[N],delete n[N],delete a[N],r[N]=!1})}})}}});FOR_BOX(e=>{e.ROOM=CLASS({init:(o,O,m)=>{let n,R,r,E={};CHECK_IS_DATA(m)!==!0?R=e.boxName+"/"+m:(n=m.roomServerName,R=e.boxName+"/"+m.name),CONNECT_TO_ROOM_SERVER.enterRoom({roomServerName:n,roomName:R});let N=(o.getRoomName=(()=>{return R}),o.checkIsExited=(()=>{return r}),O.on=((e,o)=>{let O=E[e];CONNECT_TO_ROOM_SERVER.on({roomServerName:n,methodName:R+"/"+e},o),void 0===O&&(O=E[e]=[]),O.push(o)}),O.off=((e,o)=>{let O=E[e];void 0!==O&&(void 0!==o?(CONNECT_TO_ROOM_SERVER.off({roomServerName:n,methodName:R+"/"+e},o),REMOVE({array:O,value:o}),0===O.length&&delete E[e]):(EACH(O,o=>{CONNECT_TO_ROOM_SERVER.off({roomServerName:n,methodName:R+"/"+e},o)}),delete E[e]))}));O.send=((e,o)=>{let O,m;CHECK_IS_DATA(e)!==!0?O=e:(O=e.methodName,m=e.data),r!==!0?CONNECT_TO_ROOM_SERVER.send({roomServerName:n,methodName:R+"/"+O,data:m},o):console.log("[UPPERCASE-ROOM] `ROOM.send` ERROR! ROOM EXITED!")}),O.exit=(()=>{r!==!0&&(CONNECT_TO_ROOM_SERVER.exitRoom({roomServerName:n,roomName:R}),EACH(E,(e,o)=>{N(o)}),E=void 0,r=!0)})}})});